// @see https://cloud9-sdk.readme.io/v0.1/docs/existing-tools
define(function(require, exports, module) {

    var baseHandler = require("plugins/c9.ide.language/base_handler");
    var handler = module.exports = Object.create(baseHandler);
    var workerUtil = require("plugins/c9.ide.language/worker_util");
    
    /***** Overriding handler methods *****/
    
    // Register the language.
    handler.handlesLanguage = function( language ) {
        return language === "php";
    };

    // Set up the analyzer.
    handler.analyze = function( value, ast, callback ) {
        // Get the full path to the plugin directory. Might need to find a better way to do this.
        var handlerSource = handler.$source.split("/");
        var pluginPath = handler.workspaceDir.replace("workspace", ".c9") + "/" + handlerSource[0] + "/" + handlerSource[1] + "/";
        var phpcsPath = pluginPath + "server/phpcs/";

        // Set options to use with workerUtil.execAnalysis.
        var options = {
            mode: "stdin",
            json: true,
            maxCallInterval: 500,
            timeout: 10000,
            maxBuffer: 1024 * 500, // Increase the stdout max buffer to 500KB.
            args: [
                phpcsPath + "phpcs.phar", 
                "-q",
                "-w",
                "--severity=1",
                "--report=json", 
                "--runtime-set", "ignore_errors_on_exit",  "1", 
                "--runtime-set", "ignore_warnings_on_exit", "1",
                "--runtime-set", "installed_paths", phpcsPath + "rules",
                "--runtime-set", "encoding", "utf-8",
                "--runtime-set", "report_width", "auto",
                "--runtime-set", "testVersion", "5.2-",
            //  "--runtime-set", "severity", "0",
            //  "--tab-width=4",
                "--standard=WordPress-Extra,WordPress-Docs,PHPCompatibilityWP"
            ],
        };

        // The callback used to generate the markers.
        function generateMarkers ( err, stdout, stderr ) {
            // If an error happened while retrieving data.
            if (err && err.code !== 255) return callback(err);
            
            // Parse error messages and generate markers.
            var markers = [];
            if ( typeof stdout.files.STDIN.messages !== 'undefined' ) {
                var messages = stdout.files.STDIN.messages;
                messages.forEach( function parseMessage( msg ) {
                    var marker = getMarker(msg); // Generate the marker.
                    markers.push(marker);
                });
            }
            callback( null, markers );
        }

        // Now run execAnalysis.
        workerUtil.execAnalysis( "php", options, generateMarkers );
    };

    /***** Helper Functions *****/

    // Get a marker to display based on an error message generated by PHPCS.
    function getMarker( msg ) {
        // Defining error severity.
        var severity = getSeverity( msg );
        
        // Defining message type: error or warning?
        var type = msg.type.match(/error/i) ? "🔴" : "🔶";
        
        // Can the error be fixed with PHPCBF? Please note that even though it'll display the error can be fixed with PHPCF, nothing has been implemented yet in order to do it automatically.
        var quickfix = msg.fixable ? " ✔" : "";
        
        // Defining the position of the error.
        var pos = getPosition( msg );
        
        // Defining from which coding standards this error has been found between WPCS and PHPCompatibility.
        var source = getSource( msg );
        
        // Defining the text to display in the marker.
        var message = msg.message.replace(/\.\s*$/, ""); // Strip the last '.' of the string if any.
        var text = type + " " + severity + " " + source + " " + pos + quickfix + " " + message + ".";
        
        // Generating the marker with all the previous data combined.
        var marker = {
            pos: { sl: msg.line - 1, el: msg.line - 1, sc: msg.column - 1, ec: msg.column + 1 },
            message: text,
            level: 'warning',
            quickfix: msg.fixable
        };

        return marker;
	}

	function getSeverity( msg ) {
        // Defining array of numbers to be replaced with more distinctive unicode characters.
        var severityLevels = [ 
            "⓪",
            "➀",
            "➁",
            "➂",
            "➃",
            "➄",
            "➅",
            "➆",
            "➇",
            "➈",
            "➉"
		];

		var severity = msg.severity;
		if ( typeof severityLevels[msg.severity] !== 'undefined' ) {
            severity = 5 !== severity ? severityLevels[msg.severity] : ""; // Hide the default severity (5).
        }
        
        return severity;
	}

	function getPosition( msg ) {
        // Defining array of numbers to be replaced with more distinctive unicode characters.
        var unicodeNumbers = [
            "𝟎",
            "𝟏",
            "𝟐",
            "𝟑",
            "𝟒",
            "𝟓",
            "𝟔",
            "𝟕",
            "𝟖",
            "𝟗"
        ];

		var line = replaceKeyWithValue( msg.line, unicodeNumbers );
		var col = replaceKeyWithValue( msg.column, unicodeNumbers );
		var pos = "(" +line + ":" + col + ")";

		return pos;
	}
    
    function getSource( msg ) {
        var source = msg.source;

        if ( source.match(/(wordpress)|(wp)|(squiz)|(generic)|(pear)|(psr)/i) || msg.message.match(/(wordpress)|(wp)/i) ) {
            source = "𝗪𝗣𝗖𝗦";
        } else if ( source.match(/compatibility/i) || msg.message.match(/compatibility/i) ) {
            source = "𝗣𝗛𝗣𝗖𝗼𝗺𝗽𝗮𝘁𝗶𝗯𝗶𝗹𝗶𝘁𝘆";
        } else {
            source = "[" + source.substr(0, source.indexOf('.')) + "]";
        }

        return source;
    }
    
    // In a string, replace all occurences of keys in an array with their corresponding value.
    function replaceKeyWithValue( str, arr ) {
        if ( typeof str !== 'string' ) {
            str = str.toString();
        }
        for ( var key in arr ) {
           str = str.split(key).join(arr[key]);
        }

        return str;
    }
    
});